# Appendix for "Reevaluating the Defect Proneness of Atoms of Confusion in Java Systems"
You can find [a list of AoC types](#list-of-aoc-types), [what a human-readable AST](#what-is-a-human-readable-ast), and [language factor in AoC](#aoc-and-types-of-language) in this appendix.

## TODO for this Appendix:
- [X] List of AoCs
- [X] Explain Human-Visible AST
- [ ] Examples of C/C++ AoCs that emphasize the language-specific factor

## List of AoC Types
Note: we only show the 10 AoC types studied in our paper.
| AoC Types | Abbr. | Example | Transformed |
| - | - | - | - |
| Change of Literal Encoding | CLE | `int n = 5 & 11;` | `int n = 0b0101 & 0b1011` |
| Conditional Operator | CO | `int n = (m == 3) ? 2 : 1;` | <pre>int n;<br>if (m == 3) {<br>&nbsp;&nbsp;n = 2;<br>} else {<br>&nbsp;&nbsp;n = 1;<br>}</pre> |
| Indentation | Ind | <pre>int m, n;<br>if (n == 2)<br>&nbsp;&nbsp;m = 3;<br>&nbsp;&nbsp;m = 1;</pre> | <pre>int m, n;<br>if (n == 2)<br>&nbsp;&nbsp;m = 3;<br>m = 1;</pre> |
| Infix Operator Precedence | IOP | `int n = 2 - 4 / 2` | `int n = 2 - (4 / 2)` |
| Logic as Control Flow | LCF | `boolean test = n == m && ++n > 0 \|\| ++m > 0;` | <pre>if (n == m) {<br>&nbsp;&nbsp;++n;<br>} else {<br>&nbsp;&nbsp;++m;<br>}</pre> |
| Ommitted Curly Braces | OCB | `if(n <= 0) n++; n++;` | `if(n <= 0) {n++;} n++;` |
| Post Increment/Decrement | PostID | <pre>int n = 2;<br>int m = 3 + n++;</pre> | <pre>int n = 2;<br>int m = n + 3;<br>n++;</pre> |
| Pre Increment/Decrement | PostID | <pre>int n = 2;<br>int m = ++n - 2;</pre> | <pre>int n = 2;<br>n = n + 1;<br>int m = n - 2;</pre> |
| Repurposed Variables | RV | <pre>int v1[] = new int[5];<br>v1[4] = 3;<br><br>while (v1[4] > 0) {<br>&nbsp;&nbsp;v1[3 - v1[4]] = v1[4];<br>&nbsp;&nbsp;v1[4] = v1[4] - 1;<br>}</pre> | <pre>int v1[] = new int[5];<br>int n = 5;<br><br>while (n > 0) {<br>&nbsp;&nbsp;v1[3 - v1[4]] = v1[4];<br>&nbsp;&nbsp;a = a - 1;<br>}</pre> |
| Type Conversion | TC | <pre>int n = 4;<br>char c = (char) n;</pre> | <pre>int n = 4;<br>char c = Character.forDigit(n, 10);</pre> |

## What is a Human-Visible AST? Why do we need it?
Gopstein *ea.* [[1]](#1) searched for AoC described in the following way:
> We searched for atoms in the portion of the abstract syntax tree (AST) which is visible in the source (e.g. we do not search parts of the tree generated by the preprocessor). We also search code that doesn’t directly result in AST nodes (e.g. preprocessor directive definitions). We call this slightly modified version of the AST the ‘human-visible AST’, as it is meant to replicate what a programmer can see directly when reading a program.

Their analyses deals with ratios, and project size should not affect these anlysis. Therefore, the count of AoC is divided by the number of AST nodes to mitigate the effect of commit size on the results.

To the best of our judgement, the Java Lexer tokens resemble C/C++ AST nodes the most, and they are also available to use with the Java AoC detection tool [[2]]. Therefore, we choose the Java Lexer tokens to mitigate the effect of PR size.

## AoC and Types of Language

### References
<a id="1">[1]</a>
Dan Gopstein, Hongwei Henry Zhou, Phyllis Frankl, and Justin Cappos. 2018.
Prevalence of Confusing Code in Software Projects: Atoms of Confusion in the Wild.
In Proceedings of the 15th International Conference on Mining Software Repositories (Gothenburg, Sweden) (MSR ’18).
Association for Computing Machinery, New York, NY, USA, 281–291.

<a id="2">[2]</a>
Chris Langhout and Maurício Aniche. 2021. Atoms of Confusion in Java.
In 2021 IEEE/ACM 29th International Conference on Program Comprehension (ICPC).
IEEE, New York, NY, USA, 25–35.
